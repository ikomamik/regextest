# encoding: utf-8

class Regtest::Back; end
require 'regtest/common'
require 'regtest/regex-option'
require 'regtest/back/element'
require 'regtest/back/result'

class Regtest::Back
  include Regtest::Common
  
  # Constructor
  def initialize(json_obj)
    @reg_options = @@parse_options[:reg_options]
    @reg_source = @@parse_options[:reg_source]
    @json_obj = json_obj
    
    # make a hash to manage names and corresponding objects
    @name_hash = make_name_hash(@json_obj, {})
    
    # get test cases (commented at present)
    # @test_info = Regtest::Back::TestCase.new(@json_obj, @name_hash)
    
    # default max recursion is 8.
    @max_nest = (ENV['TST_MAX_RECURSION'])?(ENV['TST_MAX_RECURSION'].to_i):8
  end
  
  # make a hash to manage names and corresponding objects
  def make_name_hash(target, name_hash)
    # register id (and refer-name in case of parenthesis)
    raise "Internal error: found duplicate id #{target["id"]}" if target["id"] && name_hash[target["id"]]
    name_hash[target["id"]] = target
    name_hash[target["refer_name"]] = target if(target["type"] == "LEX_PAREN")
    
    # recursively register names
    if(target["value"])
      if( Array === target["value"])
        target["value"].each{|child| make_name_hash(child, name_hash)}
      else
        make_name_hash(target["value"], name_hash)
      end
    end
    name_hash
  end
  
  # A public method that generates string to match the regexp
  def generate
    @parens_hash = {}  # hash to keep string generated by parentheses
    @nest = 0          # current nest of back-reference
    @quit_mode = false # flag for preventing from increase of nest
                       # if true, \g<foo> is restrained if possible
    
    # seek parentheses because there are references defined ahead
    seek_parens(@json_obj)
    
    pre_result = generate_matched_string({json: @json_obj, regopt: @reg_options})
    if pre_result
      if(result = check_look_ahead_behind(pre_result))
        if !result.narrow_down
          return nil
        end
        result.fix
      end
    else
      result = nil
    end
    result
  end
  
  # narrow down nominates considering anchors
  def check_look_ahead_behind(nominate_array)
    # pp nominate_array
    results = Regtest::Back::Result.new
    nominate_array.each do | elem |
      command = elem.command
      case command
      when :CMD_SELECT
        results.push_body elem
      when :CMD_LOOK_AHEAD, :CMD_NOT_LOOK_AHEAD
        if(sub_results = check_look_ahead_behind(elem.param[:result]))
          results.add_look_ahead(command, sub_results)
        else
          return nil
        end
      when :CMD_LOOK_BEHIND, :CMD_NOT_LOOK_BEHIND
        if(sub_results = check_look_ahead_behind(elem.param[:result]))
          results.add_look_behind(command, sub_results)
        else
          return nil
        end
      when :CMD_ANC_LINE_BEGIN, :CMD_ANC_LINE_END, :CMD_ANC_WORD_BOUND, :CMD_ANC_WORD_UNBOUND,
           :CMD_ANC_STRING_BEGIN, :CMD_ANC_STRING_END, :CMD_ANC_STRING_END2, :CMD_ANC_MATCH_START  
        results.add_anchor(command)
      else
        raise "invalid command: #{command}"
      end
    end
    if !results.merge
      return nil
    end
    
    results
  end
  
  # seek parentheses
  def seek_parens(target)
    if(target["type"] == "LEX_PAREN")
      @parens_hash[target["refer_name"]] = {:target => target}
    end
    if(target["value"])
      if( Array === target["value"])
        target["value"].each{|child| seek_parens(child)}
      else
        seek_parens(target["value"])
      end
    end
  end
  
  # generate random string to match the regexp
  def generate_matched_string(param)
    target = param[:json]
    # puts "MATCH type:#{target["type"]} #{rand(10)}"
    reg_options = param[:regopt]
    result = nil  # 結果の文字列
    case target["type"]
    when "LEX_SEQ"
      cur_options = reg_options.dup   # for preventing from rewrite in the sequence
      results = []
      target["value"].each do |elem|
        generated_string = generate_matched_string({json: elem, regopt: cur_options})
        if(Array === generated_string)
          generated_string.flatten!(1)
          results += generated_string
        else
          results.push generated_string
        end
      end
      # nil if one element failed
      if(results.index(nil))
        result = nil
      else
        # result = results.join("")
        result = results
      end
    when "LEX_SELECT"
      if param[:forced_select]
        # index is specified by condition 
        if target["value"][param[:forced_select]]
          result = generate_matched_string({json: target["value"][param[:forced_select]], regopt: reg_options})
        else
          # regexp such as /^(?:b|(a))(?(1)1)$/ match "b"!
          result = []
        end
      else
        # success if there is at least one result
        offsets = (0 ... target["value"].size).to_a
        if !param[:atomic]
          offsets.shuffle!    # shuffle if not atomic group (this proceduce is not sufficient...)
        end
        result = nil
        offsets.each do | offset |
          result = generate_matched_string({json: target["value"][offset], regopt: reg_options})
          break if(result)
        end
      end
      result
    when "LEX_PAREN"
      # analyze options of the parenthesis
      paren_prefix = target["prefix"]
      # pp target["prefix"]
      if(paren_prefix == "<=")
        lb_result = generate_matched_string({json: target["value"], regopt: reg_options})
        result = Regtest::Back::Element.new({cmd: :CMD_LOOK_BEHIND, result: lb_result})
      elsif(paren_prefix == "=")
        la_result = generate_matched_string({json: target["value"], regopt: reg_options})
        result = Regtest::Back::Element.new({cmd: :CMD_LOOK_AHEAD, result: la_result})
      elsif(paren_prefix == "<!")
        lb_result = generate_matched_string({json: target["value"], regopt: reg_options})
        result = Regtest::Back::Element.new({cmd: :CMD_NOT_LOOK_BEHIND, result: lb_result})
      elsif(paren_prefix == "!")
        la_result = generate_matched_string({json: target["value"], regopt: reg_options})
        result = Regtest::Back::Element.new({cmd: :CMD_NOT_LOOK_AHEAD, result: la_result})
      elsif(paren_prefix == ">")   # atomic group
        generate_string = generate_matched_string({json: target["value"], regopt: reg_options, atomic: true})
        @parens_hash[target["refer_name"]][:generated] ||= []
        @parens_hash[target["refer_name"]][:generated][@nest] = generate_string
        result = generate_string
      elsif(paren_prefix == "")   # simple parenthesis
        generate_string = generate_matched_string({json: target["value"], regopt: reg_options})
        @parens_hash[target["refer_name"]][:generated] ||= []
        @parens_hash[target["refer_name"]][:generated][@nest] = generate_string
        result = generate_string
      else
        # when condition is specified
        select_num = nil
        if(target["condition_name"] && target["condition_name"].length > 0)
          if @parens_hash[target["condition_name"]][:generated]
            select_num = 0
          else
            select_num = 1
          end
        end
        
        if(select_num == 1 && target["value"]["type"] != "LEX_SELECT")
          result = nil
        else
          if(md = paren_prefix.match(/^([imx]*(?:\-[imx]+)?)(:)?$/))
            if(md[2])
              # deep copy if (?imx: ) pattern
              cur_options = reg_options.dup
            else
              # replace option if (?imx) pattern
              cur_options = reg_options
            end
            cur_options.modify(md[1])
          else
            cur_options = reg_options
          end
          
          generate_string = generate_matched_string({json: target["value"], regopt: cur_options, forced_select: select_num})
          
          @parens_hash[target["refer_name"]][:generated] ||= []
          @parens_hash[target["refer_name"]][:generated][@nest] = generate_string
          result = generate_string
        end
      end
    when "LEX_CHAR_CLASS"
      results = Regtest::Back::Element.new({cmd: :CMD_SELECT, data: []})
      target["value"].each do | elem |
        sub_results = generate_matched_string({json: elem, regopt: reg_options})
        results.union sub_results
      end
      if results.size > 0
        result = results
      else
        result = nil
      end
    when "LEX_BRACKET", "LEX_SIMPLIFIED_CLASS", "LEX_ANY_LETTER", "LEX_POSIX_CHAR_CLASS", "LEX_UNICODE_CLASS"
      result = generate_matched_string({json: target["value"], regopt: reg_options})
    when "LEX_REPEAT"
      if(@quit_mode)
        repeat = target["min_repeat"]
      elsif(target["max_repeat"] > target["min_repeat"])
        repeat = target["min_repeat"]+rand(target["max_repeat"]-target["min_repeat"]+1)
      else
        repeat = target["min_repeat"]
      end
      result = []
      # puts "repeat=#{repeat} quit=#{@quit_mode} nest=#{@nest}"
      repeat.times do
        if( elem = generate_matched_string({json: target["value"], regopt: reg_options}))
          result.push elem
        else
          result = nil
          break
        end
      end
    when "LEX_RANGE"
      letter = []
      codepoints = (target["begin"]..target["end"]).to_a
      #codepoints.each do | codepoint |
      #  letter += ignore_case2([codepoint].pack("U*"), reg_options)
      #end
      letter = codepoints.map{| codepoint | [codepoint].pack("U*")}   # to be faster
      result = Regtest::Back::Element.new({cmd: :CMD_SELECT, data: letter})
    when "LEX_BACK_REFER", "LEX_NAMED_REFER"
      if @parens_hash[target["refer_name"]][:generated]
        relative_num = (target["relative_num"]=="")?(-1):(@nest + target["relative_num"].to_i)
        result = @parens_hash[target["refer_name"]][:generated][relative_num]
      else
        result = nil
      end
    when "LEX_NAMED_GENERATE"
      @quit_mode = true if(@nest >= @max_nest)
      if(@quit_mode)
        result = nil
      else
        @nest += 1
        if target["refer_name"] == "$$_0"     # recursively call whole expression
          result = generate_matched_string({json: @json_obj, regopt: @reg_options})
        else
          result = generate_matched_string({json: @parens_hash[target["refer_name"]][:target], regopt: reg_options})
        end
        @nest -= 1
      end
    when "LEX_CHAR"
      # result = ignore_case(target["value"], reg_options)
      letter = ignore_case2(target["value"], reg_options)
      result = Regtest::Back::Element.new({cmd: :CMD_SELECT, data: letter})
    when "LEX_ANC_LINE_BEGIN"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_LINE_BEGIN})
    when "LEX_ANC_LINE_END"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_LINE_END})
    when "LEX_ANC_WORD_BOUND"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_WORD_BOUND})
    when "LEX_ANC_WORD_UNBOUND"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_WORD_UNBOUND})
    when "LEX_ANC_STRING_BEGIN"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_STRING_BEGIN})
    when "LEX_ANC_STRING_END"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_STRING_END})
    when "LEX_ANC_STRING_END2"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_STRING_END2})
    when "LEX_ANC_MATCH_START"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_MATCH_START})
    when "LEX_ANC_LOOK_BEHIND2"
      result = Regtest::Back::Element.new({cmd: :CMD_ANC_LOOK_BEHIND2})
    when "LEX_EMPTY"
      result = []
    else
      raise "#{target["type"]} not implemented (from generate_matched_string routine)"
    end
    result
  end
  
  # if i option, uppercase/lowercase is rotate (this process should move to front part)
  def ignore_case2(a_char, reg_options)
    if( reg_options.is_ignore? && a_char.upcase != a_char.downcase)
      [a_char.upcase, a_char.downcase]
    else
      [a_char]
    end
  end
  
end

# Test suite (execute when this file is specified in command line)
if __FILE__ == $0

end

